## 3장 주석의 종류와 목적

### 주석의 종류와 목적

1. 문서화 주석: 형식적인 설명으로 클래스, 함수, 변수를 선언하거나 정의할때 사용된다.
2. 비형식 주석: 인라인 주석, 블록 주석 등의 형태로 정의나 선언뿐만 아니라 전반적인 소스 코드에 작성된다.

주석은 설명을 간결하게 요약하여 높은 수준으로 추상화하되, 세분화하여 작성하는 것이 좋습니다.

현재 코드를 누군가가 잘못 리팩터링할 가능성이 있을 때도 주석이 유용합니다.

코드에 대한 설명을 주석이라는 형태로 문서화함으로써 미처 발견하지 못했던 문제점을 찾아내고, 이를 토대로 리팩터링의 방향을 정하기도 합니다.

### 문서화 주석

#### 안티패턴

1. 자동으로 생성된 문서를 방치한다.
2. 선언과 같은 내용을 반복하여 쓴다.
3. 코드를 자연어로 직역한다.
   - 문서화 주석은 코드를 읽지 않아도 `코드가 무엇인지, 무엇을 하는지`를 이해할 수 있어야 합니다.
4. 개요를 작성하지 않는다.
   - 핵심이 되는 동작의 개요를 먼저 작성하는 것이 좋습니다.
5. 구현의 세부 내용을 언급한다.
   - 문서화 주석을 작성할 때 `이것을 읽는 사람이 구현의 상세를 알고 있을 것` 을 전제해서는 안됩니다.
6. 코드를 사용하는 쪽을 언급한다.
   - 문서화 주석이 설명하는 범위는 선언이나 정의에 국한 되어야 합니다.
   - 사용되는 쪽의 코드를 언급한 주석은 실제 코드와 맞지 않는, 즉 쓸모 없는 주석이 되기 쉽습니다.
  
### 문서화 주석의 구성

문서화 주석의 구성은 요약을 먼저 작성하고, 그 다음에 세부적인 내용을 보충하는 것이 좋습니다.

### 문서화 주석의 요약

요약문을 작성할 때는 문서화 도구나 규약에 규정된 문법을 따르는 것이 좋습니다.

요약에서는 그 코드가 무엇인지, 무엇을 하는지를 최대한 간결하게 설명합니다.

### 문서화 주석의 상세

주의해야 할 사항이나 이해를 돕기 위한 보충 설명이 필요한 경우네는 상세를 작성하는 것이 좋습니다. 상세는 요약과 달리 완전한 문장으로 작성하는 것이 일반적입니다.

#### 기본적인 방법

상세는 그 코드의 사용법을 구체적으로 설명함으로써 개발자가 더 쉽게 코드를 사용하도록 돕습니다.

#### 반환값의 보충 설명

부수효과가 있는 함수를 만든 경우, 기본적으로 부수효과가 무엇인지 알 수 있도록 함수 이름을 정해야 합니다.

요약은 기본적으로 부수효과에 대한 내용을 중ㅇ심으로 작성해야 합니다. 만약 요약에서 반환값을 언급할 여유가 없다면 별도의 문장으로 내용을 설명하는 것이 좋습니다.


### 비형식 주석

> 일반적으로 `해당 코드가 무엇인지`에 대한 설명을 생략하고, 코드를 작성한 배경이나 이유 또는 주의접을 적습니다.
>
> 비형식 주석은 형식이 없기 때문에 서식에 얽매이지 않고 다양한 내용을 다룰 수 있으며 주로 규모가 큰 코드를 분할하거나 직관적이지 않은 코드를 설명할 경우에 작성합니다.

#### 규모가 큰 코드 분할하기

코드 블록을 만들었는데도 빠르게 읽어 내려가기가 어렵다면 블록마다 비형식 주석을 작성하는 것이 좋습니다.

비형식 주석의 요약을 작성하는 경우에도 주석의 추상도를 높게 유지하고 세분화하여 작성하는 것이 중요합니다.

요약을 작성함으로써 얻을 수 있는 또 다른 이점은 리팩터링에 대한 힌트를 제공할 수 있다는 점입니다.

#### 직관적이지 않은 코드 설명하기


오해의 소지가 있는 코드에는 주의 사항을 추가하고, 충분히 생각해야 이해할 수 있는 코드에는 이해를 돕는 설명을 추가하는 것이 좋습니다.

주석의 길이와 상세한 정도는 큭정 코드를 이해할 필요성과 다른 코드의 가독성에 미치는 영향을 고려하여 적절한 균형을 맞춰야 합니다.

## 4장 상태

### 가변 값이 더 적합한 경우

구현 대상에 따라 가변 상태나 부수 효과를 이용하는 것이 가독성 측면에서 더 유리할 수 있다.

부분적인 불변성이나 부수 효과에만 초점을 맞추지 말고, 코드 전체의 상태 수와 전이의 복잡도 또한 확인해 봐야 합니ㅏㄷ.

### 변수 간의 관계, 직교

> 두 변수가 서로 연관성이 없거나 두 변수의 값이 서로에게 영향을 주지 않는 경우, 이들 변수의 관계를 `직교`라고 한다.

1. 함수로 대체하기
   - 변수를 제거할 대표적인 방법으로 두 변수 중 하나를 함수로 대체하기가 있습니다.
   - 대체할 수 있는지 판단해야 하는데 이를 위해서는 종속 관계라는 개념이 필요합니다.
2. 합 타입으로 대체하기
   - 합 타입이란 여러 타입을 묶어서 그 중 하나의 값을 갖는 타입

### 상태 전이의 설계

#### 불변성

> 정의, 대입, 객체 생성 이후에 상태가 변하지 않거나 외부에서 관찰할 수 없는 성질

불변과 읽기전용은 전혀 다른 개념이라는 점에 유의해야합니다.

값을 변경하는 메서드가 없다고 해서 불변성을 보장할 수 있는 것은 아닙니다.

#### 멱등성

> 한번 실행한 결과와 여러번 실행한 결과가 동일하다는 개념

객체가 취할 수 있는 상태의 수가 두 개 이하이고, 그 상태를 전환하는 함수가 한 개인 경우, 가능하면 함수가 멱등성을 지니도록 만드는 것이 좋습니다.

멱등성을 지닌 함수는 그 함수를 호출하기 전에 현재 상태를 확인하지 않아도 됩니다. 반면, 멱등성이 없는 함수인 경우에는 해당 호출이 잘못된 상태를 유발하지 않는지 미리 확인해야 합니다.


## 5장 함수

> 단일 책임의 원칙은 클래스뿐만 아니라 함수에도 적용되어야 한다.   
> 하나의 함수가 지는 책임은 오직 하나이어야 하며, 이를 위해서는 함수를 적절히 분할해야 합니다.

### 함수의 책임

#### 명령과 쿼리의 분리

> 상태를 변경하기 위한 함수(`명령`)와 상태를 알기 위한 함수(`쿼리`)를 분리해야 한다는 개념

- 명령: 수신 객체나 인수, 외부의 상태를 ㅂ녀경하는 함수, 반환값을 가지지 않는다.
- 쿼리: 반환값으로 정보를 취득하는 함수, 수신 객체나 인수, 외부의 상태는 변경하지 않는다.

명령과 쿼리의 분리 원칙 역시 가독성과 견고함을 향상시키기 위한 수단 중 하나일뿐, 그 자체가 목적이 되어서는 안됩니다. 이 원칙을 지나치게 적용하면 불필요한 상태를 유지하게 되고 그 결과, 함수와 호출자 사이에 강한 의존 관계가 발생하게 됩니다.

### 함수의 흐름

#### 정의 기반 프로그래밍

> 변수, 함수, 클래스의 정의를 주로 사용하는 프로그래밍 스타일

- 높은 수준의 추상화
- 빠르게 읽어 내려가도 쉽게 파악할 수 있는 코드
- 되짚어 읽지 않아도 되는 코드

**[개선해야 할 패턴1 - 중첩]**

인수의 중첩 때문에 발생하는 문제

1. 중요한 코드인지 알기 어렵다
2. 반환값의 의미를 파악하기 어렵다

정의 기반 프로그래밍에서는 지역변수와 비공개 함수를 구분하여 사용합니다. 만약 지역 변수만으로도 충분하다면 비공개 함수를 사용하는 방법은 고려하지 않아도 좋습니다.

> 지역 변수나 비공개 함수를 사용하면 중첩을 제거하거나 숨길 수 있습니다.
>
> 함수가 하는 일을 강조할 수 있고, 전체적인 코드의 가독성을 향상시킬 수도 있습니다.

**[개선해야 할 패턴2 - 메서드 체인]**

> 메서드 체인이란?
>
> 반환값을 새로운 수신 객체로 삼아 또 다른 메서드를 호출하는 것

**[이점]**

- 함수의 평가와 실행은 위부터 순차적으로 이루어지기 때문에 되짚어 읽을 일이 줄어든다.
- 중첩의 깊이가 얕아지기 때문에 메서드와 인수의 관계를 쉽게 파악할 수 있다.

**[개선해야 할 패턴3 - 리터럴]**

> 리터럴(직접 값)은 소스 코드에서 직접 표현된 값입니다.

정의 기반 프로그래밍에서는 매직넘버에 이름 부여하는 방식에 더하여 `람다식이나 익명 객체`와 같은 리터럴을 다루는 방법도 제시합니다.

#### 조기 반환

성공 경로를 처리하는 코드를 눈에 띄게 하고, 실패 경로의 조건과 처리는 깔끔하게 정리하기 위해 조기 반환을 활용하는 것이 좋습니다.

**[주의할 점1 - 이해하기 어려운 반환은 피할 것]**

분기의 내부에 위치하거나 중첩된 람다식 내부에서 비지역적으로 위치하면 실패 경로의 조건을 이해하기가 어려워 집니다.

**[주의할 점2 - 불필요한 실패 경로를 만들지 말 것]**

조기 반환을 적용하기 전에는 반드시 실패 경로가 꼭 필요한지를 먼저 확인해야 합니다.

#### 조작 대상에 따른 분할

표시할 요소별로 함수를 분할하면 앞서 언급한 대로 무엇을 하는 함수인지 알수 없는 문제와 커버리지를 보장할 수 없는 문제를 동시에 해결할 수있습니다.


